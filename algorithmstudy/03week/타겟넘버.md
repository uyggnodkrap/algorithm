# 🔒 문제

[코딩테스트 연습 - 타겟 넘버](https://programmers.co.kr/learn/courses/30/lessons/43165)

## 🔎 문제 설명

n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

```
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

## 🔎 제한사항

- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

## 🔎 **입출력 예**

| numbers | target | return |
| --- | --- | --- |
| [1, 1, 1, 1, 1] | 3 | 5 |
| [4, 1, 2, 1] | 4 | 2 |

## 📋 **입출력 예 설명**

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

```
+4+1-2+1 = 4
+4-1+2-1 = 4
```

- 총 2가지 방법이 있으므로, 2를 return 합니다

## 🔓 풀이 1

1. cartisian product를 활용한 완전탐색으로 풀자는 마인드
    1. 중간에 수 틀리면 중지하거나 탈출하거나 그런 로직을 짤 수는 없다고 판단했기 때문이다.
    2. 그렇다면 모든 경우의 수를 다 만들어 놓은 다음, 조건에 맞는 경우를 찾는 방향으로 구현하면 된다.
2. 제한사항에 주어지는 숫자는 자연수이므로, 각 수의 양수와 음수를 담은 리스트를 초기화한다. 
3. 해당 리스트의 cartirsan product를 구하고, 각 원소의 합의 정보를 담은 리스트를 초기화한다. 
4. 리스트 내에 값이 `target`인 원소의 개수를 반환한다. 

```python
from itertools import product

def solution(numbers, target):
    num = [(x, -x) for x in numbers]
    prod = list(map(sum, product(*num)))

    return prod.count(target)
```

### 🔎 결과

| 테스트 1 〉 | 통과 (233.33ms, 34.6MB) |
| --- | --- |
| 테스트 2 〉 | 통과 (246.85ms, 34MB) |
| 테스트 3 〉 | 통과 (0.19ms, 10.2MB) |
| 테스트 4 〉 | 통과 (0.73ms, 10.3MB) |
| 테스트 5 〉 | 통과 (6.60ms, 10.8MB) |
| 테스트 6 〉 | 통과 (0.36ms, 10.2MB) |
| 테스트 7 〉 | 통과 (0.18ms, 10.2MB) |
| 테스트 8 〉 | 통과 (1.62ms, 10.3MB) |

## 🔓 풀이 2

1. 트리의 완전탐색으로 풀자는 마인드
2. 트리의 최상위 node를 0으로 초기화한다. 
3. numbers의 각 원소에 대해서, 다음 원소와의 합, 또는 차의 경우를 모두 담은 리스트를 생성한다. 
4. 리스트 내에 값이 `target`인 원소의 개수를 반환한다. 

```python
def solution(numbers, target):
    node = [0]
    for i in numbers:
        leaf = []
        for n in node:
            leaf.append(n+i)
            leaf.append(n-i)
            
        node = leaf

    return node.count(target)
```

### 🔎 결과

| 테스트 1 〉 | 통과 (160.72ms, 50MB) |
| --- | --- |
| 테스트 2 〉 | 통과 (151.27ms, 49.4MB) |
| 테스트 3 〉 | 통과 (0.15ms, 10.1MB) |
| 테스트 4 〉 | 통과 (0.59ms, 10.3MB) |
| 테스트 5 〉 | 통과 (4.88ms, 11.1MB) |
| 테스트 6 〉 | 통과 (0.29ms, 10.3MB) |
| 테스트 7 〉 | 통과 (0.15ms, 10.2MB) |
| 테스트 8 〉 | 통과 (1.24ms, 10.5MB) |

## 📎결론

- 풀이 1은 느리고, 풀이 2는 메모리를 더 잡아먹는다. 구현은 1이 직관적이였다,.